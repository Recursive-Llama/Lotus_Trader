# Decision Maker Module - Build Plan

*Comprehensive implementation guide for the Decision Maker module in the organic intelligence system*

## Executive Summary

This build plan implements the Decision Maker module that evaluates, approves, modifies, or rejects trading plans generated by the Alpha Detector. The module provides governance and risk management while maintaining clear separation of concerns.

## Phase 1: Core Architecture (Weeks 1-4)

### 1.1 Decision Maker Core Class

```python
from dataclasses import dataclass
from typing import Dict, List, Optional, Any, Tuple
from enum import Enum
import numpy as np
import pandas as pd
from datetime import datetime, timedelta

class DecisionType(Enum):
    APPROVE = "approve"
    MODIFY = "modify"
    REJECT = "reject"

@dataclass
class TradingPlan:
    """Complete trading plan from Alpha Detector"""
    signal_id: str
    symbol: str
    signal_strength: float
    direction: str  # 'long', 'short', 'neutral'
    entry_conditions: Dict[str, Any]
    position_size: float
    stop_loss: Optional[float]
    take_profit: Optional[float]
    time_horizon: int  # minutes
    risk_reward_ratio: float
    confidence_score: float
    microstructure_evidence: Dict[str, Any]
    regime_context: Dict[str, Any]
    execution_notes: str
    valid_until: datetime
    detector_metadata: Dict[str, Any]

@dataclass
class DecisionResult:
    """Decision result from Decision Maker"""
    decision_id: str
    signal_id: str
    decision_type: DecisionType
    original_plan: TradingPlan
    modified_plan: Optional[TradingPlan]
    rejection_reasons: List[str]
    curator_feedback: List[Dict[str, Any]]
    risk_assessment: Dict[str, Any]
    budget_allocation: float
    created_at: datetime

class DecisionMaker:
    """Main Decision Maker class"""
    
    def __init__(self, config: Dict[str, Any]):
        self.config = config
        self.curators = self._initialize_curators()
        self.context_engine = ContextEngine(config)
        self.alpha_normalizer = AlphaNormalizer(config)
        self.fusion_engine = FusionEngine(config)
        self.portfolio_allocator = PortfolioAllocator(config)
        self.crypto_asymmetry = CryptoAsymmetryModule(config)
        self.learning_system = DecisionMakerLearning(config)
        
    def evaluate_trading_plan(self, trading_plan: TradingPlan) -> DecisionResult:
        """Main decision process"""
        
        # 1. Get portfolio context
        portfolio_context = self.context_engine.get_portfolio_context()
        
        # 2. Normalize signal to dm_alpha format
        dm_alpha = self.alpha_normalizer.normalize_signal(
            trading_plan.signal_strength, trading_plan
        )
        
        # 3. Curator evaluation
        curator_decisions = self._evaluate_curators(trading_plan, portfolio_context)
        
        # 4. Check for vetoes
        if self._has_vetoes(curator_decisions):
            return self._create_rejection_decision(
                trading_plan, curator_decisions, portfolio_context
            )
        
        # 5. Risk assessment
        risk_assessment = self._assess_plan_risk(trading_plan, portfolio_context)
        
        # 6. Budget allocation
        budget_allocation = self._allocate_budget(trading_plan, portfolio_context)
        
        # 7. Check for modifications needed
        if self._needs_modifications(curator_decisions, risk_assessment):
            modified_plan = self._apply_modifications(
                trading_plan, curator_decisions, risk_assessment
            )
            return self._create_modification_decision(
                trading_plan, modified_plan, curator_decisions, 
                risk_assessment, budget_allocation
            )
        
        # 8. Approve plan
        return self._create_approval_decision(
            trading_plan, curator_decisions, risk_assessment, budget_allocation
        )
```

### 1.2 Curator Implementation

```python
class RiskCurator:
    """Risk management curator"""
    
    def __init__(self, config: Dict[str, Any]):
        self.max_position_size = config.get('max_position_size', 0.05)
        self.max_portfolio_risk = config.get('max_portfolio_risk', 0.20)
        self.correlation_threshold = config.get('correlation_threshold', 0.7)
        
    def evaluate(self, trading_plan: TradingPlan, portfolio_context: Dict) -> Dict[str, Any]:
        """Evaluate risk aspects of trading plan"""
        
        # Position size risk
        position_risk = self._calculate_position_risk(trading_plan)
        
        # Portfolio impact risk
        portfolio_impact = self._calculate_portfolio_impact(trading_plan, portfolio_context)
        
        # Correlation risk
        correlation_risk = self._calculate_correlation_risk(trading_plan, portfolio_context)
        
        # Combined risk score
        risk_score = self._combine_risk_scores(position_risk, portfolio_impact, correlation_risk)
        
        # Determine action
        if risk_score > 0.8:
            action = "veto"
            contribution = 0.0
        elif risk_score > 0.6:
            action = "nudge"
            contribution = -0.1  # Reduce position size
        else:
            action = "approve"
            contribution = 0.0
            
        return {
            "curator_type": "risk",
            "action": action,
            "contribution": contribution,
            "risk_score": risk_score,
            "position_risk": position_risk,
            "portfolio_impact": portfolio_impact,
            "correlation_risk": correlation_risk,
            "reason": f"Risk score: {risk_score:.3f}"
        }
    
    def _calculate_position_risk(self, trading_plan: TradingPlan) -> float:
        """Calculate position-specific risk"""
        # Position size relative to max allowed
        size_risk = min(trading_plan.position_size / self.max_position_size, 1.0)
        
        # Risk-reward ratio assessment
        rr_risk = 1.0 - min(trading_plan.risk_reward_ratio / 2.0, 1.0)
        
        # Confidence-based risk adjustment
        confidence_risk = 1.0 - trading_plan.confidence_score
        
        # Combined position risk
        return (size_risk + rr_risk + confidence_risk) / 3.0
    
    def _calculate_portfolio_impact(self, trading_plan: TradingPlan, portfolio_context: Dict) -> float:
        """Calculate portfolio impact risk"""
        current_positions = portfolio_context.get('positions', {})
        total_capital = portfolio_context.get('total_capital', 1.0)
        
        # Calculate new portfolio risk after adding position
        new_portfolio_risk = self._calculate_new_portfolio_risk(
            trading_plan, current_positions, total_capital
        )
        
        # Risk relative to max portfolio risk
        return min(new_portfolio_risk / self.max_portfolio_risk, 1.0)
    
    def _calculate_correlation_risk(self, trading_plan: TradingPlan, portfolio_context: Dict) -> float:
        """Calculate correlation risk with existing positions"""
        correlation_matrix = portfolio_context.get('correlation_matrix', {})
        symbol = trading_plan.symbol
        
        if symbol not in correlation_matrix:
            return 0.0
        
        # Find highest correlation with existing positions
        max_correlation = 0.0
        for other_symbol, correlation in correlation_matrix[symbol].items():
            if other_symbol != symbol:
                max_correlation = max(max_correlation, abs(correlation))
        
        # Risk increases with correlation
        return max_correlation

class AllocationCurator:
    """Asset allocation curator"""
    
    def __init__(self, config: Dict[str, Any]):
        self.max_concentration = config.get('max_concentration', 0.10)
        self.diversification_target = config.get('diversification_target', 0.05)
        
    def evaluate(self, trading_plan: TradingPlan, portfolio_context: Dict) -> Dict[str, Any]:
        """Evaluate allocation aspects of trading plan"""
        
        # Concentration risk
        concentration_risk = self._calculate_concentration_risk(trading_plan, portfolio_context)
        
        # Diversification benefit
        diversification_benefit = self._calculate_diversification_benefit(trading_plan, portfolio_context)
        
        # Allocation score
        allocation_score = self._calculate_allocation_score(concentration_risk, diversification_benefit)
        
        # Determine action
        if allocation_score < 0.3:
            action = "veto"
            contribution = 0.0
        elif allocation_score < 0.6:
            action = "nudge"
            contribution = 0.05  # Slight positive nudge
        else:
            action = "approve"
            contribution = 0.0
            
        return {
            "curator_type": "allocation",
            "action": action,
            "contribution": contribution,
            "allocation_score": allocation_score,
            "concentration_risk": concentration_risk,
            "diversification_benefit": diversification_benefit,
            "reason": f"Allocation score: {allocation_score:.3f}"
        }
```

### 1.3 Context Engine

```python
class ContextEngine:
    """Maintains portfolio state and context"""
    
    def __init__(self, config: Dict[str, Any]):
        self.config = config
        self.portfolio_state = PortfolioState()
        self.risk_budgets = RiskBudgets()
        self.constraints = Constraints()
        
    def get_portfolio_context(self) -> Dict[str, Any]:
        """Get current portfolio context"""
        return {
            'total_capital': self.portfolio_state.get_total_capital(),
            'available_capital': self.portfolio_state.get_available_capital(),
            'positions': self.portfolio_state.get_positions(),
            'risk_budget': self.risk_budgets.get_available_risk(),
            'constraints': self.constraints.get_active_constraints(),
            'correlation_matrix': self.portfolio_state.get_correlation_matrix(),
            'volatility_forecast': self.portfolio_state.get_volatility_forecast(),
            'market_regime': self.portfolio_state.get_market_regime()
        }

class PortfolioState:
    """Maintains current portfolio state"""
    
    def __init__(self):
        self.positions: Dict[str, float] = {}
        self.total_capital: float = 1000000.0  # $1M default
        self.correlation_matrix: Dict[str, Dict[str, float]] = {}
        
    def get_total_capital(self) -> float:
        """Get total portfolio capital"""
        return self.total_capital
    
    def get_available_capital(self) -> float:
        """Get available capital for new positions"""
        used_capital = sum(abs(size) for size in self.positions.values())
        return self.total_capital - used_capital
    
    def get_positions(self) -> Dict[str, float]:
        """Get current positions"""
        return self.positions.copy()
    
    def get_correlation_matrix(self) -> Dict[str, Dict[str, float]]:
        """Get correlation matrix for all positions"""
        return self.correlation_matrix.copy()
    
    def update_position(self, symbol: str, size: float):
        """Update position size"""
        self.positions[symbol] = size
        
    def get_volatility_forecast(self) -> Dict[str, float]:
        """Get volatility forecast for all positions"""
        # Simplified volatility forecast
        return {symbol: 0.02 for symbol in self.positions.keys()}
    
    def get_market_regime(self) -> str:
        """Get current market regime"""
        # Simplified regime detection
        return "normal"
```

## Phase 2: Risk Management (Weeks 5-8)

### 2.1 Risk Assessment Engine

```python
class RiskAssessmentEngine:
    """Comprehensive risk assessment"""
    
    def __init__(self, config: Dict[str, Any]):
        self.config = config
        self.var_calculator = VaRCalculator()
        self.correlation_analyzer = CorrelationAnalyzer()
        self.stress_tester = StressTester()
        
    def assess_plan_risk(self, trading_plan: TradingPlan, portfolio_context: Dict) -> Dict[str, Any]:
        """Assess comprehensive risk of trading plan"""
        
        # Position risk
        position_risk = self._calculate_position_risk(trading_plan)
        
        # Portfolio impact
        portfolio_impact = self._calculate_portfolio_impact(trading_plan, portfolio_context)
        
        # Correlation risk
        correlation_risk = self._calculate_correlation_risk(trading_plan, portfolio_context)
        
        # VaR impact
        var_impact = self._calculate_var_impact(trading_plan, portfolio_context)
        
        # Stress test impact
        stress_impact = self._calculate_stress_impact(trading_plan, portfolio_context)
        
        # Combined risk score
        total_risk = self._combine_risk_metrics(
            position_risk, portfolio_impact, correlation_risk, var_impact, stress_impact
        )
        
        return {
            "total_risk": total_risk,
            "position_risk": position_risk,
            "portfolio_impact": portfolio_impact,
            "correlation_risk": correlation_risk,
            "var_impact": var_impact,
            "stress_impact": stress_impact,
            "risk_level": self._classify_risk_level(total_risk)
        }
    
    def _calculate_position_risk(self, trading_plan: TradingPlan) -> float:
        """Calculate position-specific risk"""
        # Position size risk
        size_risk = min(trading_plan.position_size / 0.05, 1.0)  # 5% max position
        
        # Stop loss risk
        stop_loss_risk = 0.0
        if trading_plan.stop_loss:
            stop_loss_risk = abs(trading_plan.entry_price - trading_plan.stop_loss) / trading_plan.entry_price
        
        # Time horizon risk
        time_risk = min(trading_plan.time_horizon / 1440, 1.0)  # 24 hours max
        
        # Combined position risk
        return (size_risk + stop_loss_risk + time_risk) / 3.0
    
    def _calculate_portfolio_impact(self, trading_plan: TradingPlan, portfolio_context: Dict) -> float:
        """Calculate portfolio impact"""
        current_positions = portfolio_context.get('positions', {})
        total_capital = portfolio_context.get('total_capital', 1.0)
        
        # Calculate new portfolio composition
        new_positions = current_positions.copy()
        new_positions[trading_plan.symbol] = trading_plan.position_size
        
        # Calculate portfolio volatility
        current_vol = self._calculate_portfolio_volatility(current_positions)
        new_vol = self._calculate_portfolio_volatility(new_positions)
        
        # Impact is increase in volatility
        return min((new_vol - current_vol) / current_vol, 1.0) if current_vol > 0 else 0.0
    
    def _calculate_correlation_risk(self, trading_plan: TradingPlan, portfolio_context: Dict) -> float:
        """Calculate correlation risk"""
        correlation_matrix = portfolio_context.get('correlation_matrix', {})
        symbol = trading_plan.symbol
        
        if symbol not in correlation_matrix:
            return 0.0
        
        # Find maximum correlation with existing positions
        max_correlation = 0.0
        for other_symbol, correlation in correlation_matrix[symbol].items():
            if other_symbol != symbol:
                max_correlation = max(max_correlation, abs(correlation))
        
        return max_correlation
    
    def _calculate_var_impact(self, trading_plan: TradingPlan, portfolio_context: Dict) -> float:
        """Calculate VaR impact"""
        # Simplified VaR calculation
        position_value = trading_plan.position_size * trading_plan.entry_price
        portfolio_value = portfolio_context.get('total_capital', 1.0)
        
        # VaR impact as percentage of portfolio
        var_impact = position_value / portfolio_value
        
        return min(var_impact, 1.0)
    
    def _calculate_stress_impact(self, trading_plan: TradingPlan, portfolio_context: Dict) -> float:
        """Calculate stress test impact"""
        # Simplified stress test
        stress_scenarios = [-0.1, -0.05, -0.02]  # -10%, -5%, -2%
        
        max_loss = 0.0
        for scenario in stress_scenarios:
            loss = abs(trading_plan.position_size * scenario)
            max_loss = max(max_loss, loss)
        
        portfolio_value = portfolio_context.get('total_capital', 1.0)
        stress_impact = max_loss / portfolio_value
        
        return min(stress_impact, 1.0)
    
    def _combine_risk_metrics(self, *risk_metrics) -> float:
        """Combine multiple risk metrics"""
        # Weighted average of risk metrics
        weights = [0.3, 0.25, 0.2, 0.15, 0.1]  # Position, Portfolio, Correlation, VaR, Stress
        return sum(w * r for w, r in zip(weights, risk_metrics))
    
    def _classify_risk_level(self, total_risk: float) -> str:
        """Classify risk level"""
        if total_risk < 0.3:
            return "low"
        elif total_risk < 0.6:
            return "medium"
        else:
            return "high"
```

### 2.2 Budget Allocation

```python
class BudgetAllocator:
    """Portfolio budget allocation"""
    
    def __init__(self, config: Dict[str, Any]):
        self.config = config
        self.kelly_calculator = KellyCalculator()
        self.crypto_asymmetry = CryptoAsymmetryModule(config)
        
    def allocate_budget(self, trading_plan: TradingPlan, portfolio_context: Dict) -> float:
        """Allocate budget for trading plan"""
        
        # Get base budget
        base_budget = portfolio_context.get('risk_budget', 0.01)  # 1% default
        
        # Apply Kelly criterion
        kelly_fraction = self.kelly_calculator.calculate_kelly_fraction(trading_plan)
        
        # Apply crypto asymmetry scaling
        if self._is_crypto_asset(trading_plan.symbol):
            asymmetry_score = self.crypto_asymmetry.calculate_asymmetry_score(trading_plan)
            scaled_budget = self.crypto_asymmetry.scale_budget(base_budget, asymmetry_score)
        else:
            scaled_budget = base_budget
        
        # Apply safety brakes
        final_budget = self._apply_safety_brakes(scaled_budget, kelly_fraction, trading_plan)
        
        return final_budget
    
    def _is_crypto_asset(self, symbol: str) -> bool:
        """Check if asset is crypto"""
        crypto_symbols = ['BTC', 'ETH', 'SOL', 'ADA', 'DOT', 'LINK', 'UNI', 'AAVE']
        return symbol in crypto_symbols
    
    def _apply_safety_brakes(self, budget: float, kelly_fraction: float, trading_plan: TradingPlan) -> float:
        """Apply safety brakes to budget"""
        # Kelly fraction cap
        kelly_cap = 0.25  # Max 25% of Kelly
        budget = min(budget, kelly_fraction * kelly_cap)
        
        # Concentration limit
        concentration_limit = 0.10  # Max 10% of portfolio
        budget = min(budget, concentration_limit)
        
        # Drawdown-aware ratchet
        if hasattr(trading_plan, 'drawdown_aware'):
            drawdown_factor = 1.0 - trading_plan.drawdown_aware
            budget *= drawdown_factor
        
        return max(budget, 0.0)  # Ensure non-negative

class KellyCalculator:
    """Kelly criterion calculator"""
    
    def calculate_kelly_fraction(self, trading_plan: TradingPlan) -> float:
        """Calculate Kelly fraction for position sizing"""
        
        # Expected return
        expected_return = trading_plan.signal_strength * 0.01  # Convert to return
        
        # Expected variance
        expected_variance = 0.02 ** 2  # 2% daily volatility
        
        # Kelly fraction = (expected_return - risk_free_rate) / expected_variance
        risk_free_rate = 0.0  # Assume zero risk-free rate
        kelly_fraction = (expected_return - risk_free_rate) / expected_variance
        
        # Cap at reasonable maximum
        return min(kelly_fraction, 0.5)  # Max 50%
```

## Phase 3: Crypto Asymmetry Module (Weeks 9-12)

### 3.1 Asymmetry Detectors

```python
class CryptoAsymmetryModule:
    """Crypto-specific asymmetry detection and budget scaling"""
    
    def __init__(self, config: Dict[str, Any]):
        self.config = config
        self.detectors = {
            'oi_squeeze': OISqueezeDetector(),
            'funding_imbalance': FundingImbalanceDetector(),
            'basis_stress': BasisStressDetector(),
            'depth_vacuum': DepthVacuumDetector()
        }
        self.asymmetry_threshold = config.get('asymmetry_threshold', 0.5)
        self.budget_scaling_factor = config.get('budget_scaling_factor', 1.5)
        
    def calculate_asymmetry_score(self, trading_plan: TradingPlan) -> float:
        """Calculate overall asymmetry score"""
        asymmetry_scores = {}
        
        for name, detector in self.detectors.items():
            try:
                score = detector.detect(trading_plan)
                asymmetry_scores[name] = score
            except Exception as e:
                print(f"Error in {name} detector: {e}")
                asymmetry_scores[name] = 0.0
        
        # Weighted combination of asymmetry scores
        weights = {
            'oi_squeeze': 0.3,
            'funding_imbalance': 0.25,
            'basis_stress': 0.25,
            'depth_vacuum': 0.2
        }
        
        combined_score = sum(weights[name] * score for name, score in asymmetry_scores.items())
        return min(combined_score, 1.0)
    
    def scale_budget(self, base_budget: float, asymmetry_score: float) -> float:
        """Scale budget based on asymmetry score"""
        if asymmetry_score > self.asymmetry_threshold:
            # High asymmetry - increase budget
            scaling_factor = 1.0 + (asymmetry_score - self.asymmetry_threshold) * self.budget_scaling_factor
            return base_budget * scaling_factor
        else:
            # Low asymmetry - decrease budget
            scaling_factor = 0.5 + (asymmetry_score / self.asymmetry_threshold) * 0.5
            return base_budget * scaling_factor

class OISqueezeDetector:
    """Open Interest squeeze detector"""
    
    def detect(self, trading_plan: TradingPlan) -> float:
        """Detect OI squeeze asymmetry"""
        # Simplified OI squeeze detection
        # In practice, this would analyze order book data
        
        # Extract relevant data from trading plan
        microstructure_evidence = trading_plan.microstructure_evidence
        oi_data = microstructure_evidence.get('open_interest', {})
        
        if not oi_data:
            return 0.0
        
        # Calculate OI squeeze score
        oi_change = oi_data.get('change', 0.0)
        oi_volume_ratio = oi_data.get('volume_ratio', 1.0)
        
        # Squeeze occurs when OI increases faster than volume
        squeeze_score = max(0.0, oi_change - oi_volume_ratio)
        
        return min(squeeze_score, 1.0)

class FundingImbalanceDetector:
    """Funding rate imbalance detector"""
    
    def detect(self, trading_plan: TradingPlan) -> float:
        """Detect funding rate imbalance"""
        microstructure_evidence = trading_plan.microstructure_evidence
        funding_data = microstructure_evidence.get('funding_rate', {})
        
        if not funding_data:
            return 0.0
        
        # Calculate funding imbalance
        funding_rate = funding_data.get('rate', 0.0)
        funding_velocity = funding_data.get('velocity', 0.0)
        
        # Imbalance occurs when funding rate is extreme and accelerating
        imbalance_score = abs(funding_rate) * abs(funding_velocity)
        
        return min(imbalance_score, 1.0)

class BasisStressDetector:
    """Basis stress detector"""
    
    def detect(self, trading_plan: TradingPlan) -> float:
        """Detect basis stress"""
        microstructure_evidence = trading_plan.microstructure_evidence
        basis_data = microstructure_evidence.get('basis', {})
        
        if not basis_data:
            return 0.0
        
        # Calculate basis stress
        basis_spread = basis_data.get('spread', 0.0)
        basis_volatility = basis_data.get('volatility', 0.0)
        
        # Stress occurs when basis spread is wide and volatile
        stress_score = abs(basis_spread) * basis_volatility
        
        return min(stress_score, 1.0)

class DepthVacuumDetector:
    """Order book depth vacuum detector"""
    
    def detect(self, trading_plan: TradingPlan) -> float:
        """Detect order book depth vacuum"""
        microstructure_evidence = trading_plan.microstructure_evidence
        depth_data = microstructure_evidence.get('order_book_depth', {})
        
        if not depth_data:
            return 0.0
        
        # Calculate depth vacuum
        bid_depth = depth_data.get('bid_depth', 0.0)
        ask_depth = depth_data.get('ask_depth', 0.0)
        spread = depth_data.get('spread', 0.0)
        
        # Vacuum occurs when depth is low and spread is wide
        vacuum_score = (1.0 - min(bid_depth, ask_depth)) * spread
        
        return min(vacuum_score, 1.0)
```

## Phase 4: Self-Learning System (Weeks 13-16)

### 4.1 Learning Implementation

```python
class DecisionMakerLearning:
    """Self-learning system for Decision Maker"""
    
    def __init__(self, config: Dict[str, Any]):
        self.config = config
        self.performance_history = []
        self.learning_rate = config.get('learning_rate', 0.01)
        self.adaptation_threshold = config.get('adaptation_threshold', 0.1)
        
    def update_performance(self, decision_id: str, outcome: Dict[str, Any]):
        """Update performance based on decision outcome"""
        performance_record = {
            'decision_id': decision_id,
            'outcome': outcome,
            'timestamp': datetime.now(),
            'pnl': outcome.get('pnl', 0.0),
            'execution_quality': outcome.get('execution_quality', 0.0),
            'risk_realized': outcome.get('risk_realized', 0.0)
        }
        
        self.performance_history.append(performance_record)
        
        # Trigger learning if performance degrades
        if self._performance_degraded():
            self._adapt_parameters()
    
    def _performance_degraded(self) -> bool:
        """Check if performance has degraded"""
        if len(self.performance_history) < 10:
            return False
        
        # Calculate recent performance
        recent_performance = self._calculate_recent_performance(10)
        historical_performance = self._calculate_historical_performance(50)
        
        # Performance degraded if recent is significantly worse
        return recent_performance < historical_performance * (1 - self.adaptation_threshold)
    
    def _adapt_parameters(self):
        """Adapt decision maker parameters"""
        # Analyze performance patterns
        patterns = self._analyze_performance_patterns()
        
        # Update curator weights
        for pattern in patterns:
            if pattern['type'] == 'curator_weight_update':
                self._update_curator_weights(pattern['weights'])
            elif pattern['type'] == 'risk_threshold_adjustment':
                self._adjust_risk_thresholds(pattern['adjustment'])
    
    def _calculate_recent_performance(self, window: int) -> float:
        """Calculate recent performance"""
        recent_records = self.performance_history[-window:]
        if not recent_records:
            return 0.0
        
        # Weighted average of PnL and execution quality
        total_performance = 0.0
        total_weight = 0.0
        
        for record in recent_records:
            weight = 1.0  # Equal weight for now
            performance = record['pnl'] * 0.7 + record['execution_quality'] * 0.3
            total_performance += performance * weight
            total_weight += weight
        
        return total_performance / total_weight if total_weight > 0 else 0.0
    
    def _calculate_historical_performance(self, window: int) -> float:
        """Calculate historical performance"""
        if len(self.performance_history) < window:
            return self._calculate_recent_performance(len(self.performance_history))
        
        historical_records = self.performance_history[-window:-10]  # Exclude recent
        if not historical_records:
            return 0.0
        
        # Same calculation as recent performance
        total_performance = 0.0
        total_weight = 0.0
        
        for record in historical_records:
            weight = 1.0
            performance = record['pnl'] * 0.7 + record['execution_quality'] * 0.3
            total_performance += performance * weight
            total_weight += weight
        
        return total_performance / total_weight if total_weight > 0 else 0.0
    
    def _analyze_performance_patterns(self) -> List[Dict[str, Any]]:
        """Analyze performance patterns for adaptation"""
        patterns = []
        
        # Analyze curator performance
        curator_performance = self._analyze_curator_performance()
        if curator_performance:
            patterns.append({
                'type': 'curator_weight_update',
                'weights': curator_performance
            })
        
        # Analyze risk threshold performance
        risk_performance = self._analyze_risk_threshold_performance()
        if risk_performance:
            patterns.append({
                'type': 'risk_threshold_adjustment',
                'adjustment': risk_performance
            })
        
        return patterns
    
    def _analyze_curator_performance(self) -> Optional[Dict[str, float]]:
        """Analyze individual curator performance"""
        # Simplified curator performance analysis
        # In practice, this would analyze curator decisions vs outcomes
        
        # For now, return equal weights
        return {
            'risk': 0.3,
            'allocation': 0.2,
            'timing': 0.2,
            'cost': 0.15,
            'compliance': 0.15
        }
    
    def _analyze_risk_threshold_performance(self) -> Optional[Dict[str, float]]:
        """Analyze risk threshold performance"""
        # Simplified risk threshold analysis
        # In practice, this would analyze risk decisions vs realized risk
        
        # For now, return no adjustment
        return None
```

## Database Schema

### Decision Maker Tables
```sql
-- Trading plan decisions
CREATE TABLE dm_decisions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    signal_id UUID NOT NULL,
    decision_type TEXT NOT NULL CHECK (decision_type IN ('approve', 'modify', 'reject')),
    original_plan JSONB NOT NULL,
    modified_plan JSONB,
    rejection_reasons TEXT[],
    curator_decisions JSONB NOT NULL,
    risk_assessment JSONB NOT NULL,
    budget_allocation FLOAT8,
    created_at TIMESTAMP DEFAULT NOW(),
    INDEX idx_dm_decisions_signal (signal_id),
    INDEX idx_dm_decisions_type (decision_type),
    INDEX idx_dm_decisions_created (created_at)
);

-- Portfolio context snapshots
CREATE TABLE dm_portfolio_context (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    snapshot_time TIMESTAMP NOT NULL,
    total_capital FLOAT8 NOT NULL,
    available_capital FLOAT8 NOT NULL,
    risk_budget FLOAT8 NOT NULL,
    positions JSONB NOT NULL,
    correlation_matrix JSONB NOT NULL,
    constraints JSONB NOT NULL,
    INDEX idx_dm_portfolio_context_time (snapshot_time)
);

-- Curator actions
CREATE TABLE dm_curator_actions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    decision_id UUID REFERENCES dm_decisions(id),
    curator_type TEXT NOT NULL,
    action_type TEXT NOT NULL CHECK (action_type IN ('veto', 'nudge', 'approve')),
    contribution FLOAT8,
    reason TEXT,
    evidence JSONB,
    created_at TIMESTAMP DEFAULT NOW(),
    INDEX idx_dm_curator_actions_decision (decision_id),
    INDEX idx_dm_curator_actions_curator (curator_type)
);

-- Crypto asymmetry scores
CREATE TABLE dm_crypto_asymmetry (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    symbol TEXT NOT NULL,
    asymmetry_score FLOAT8 NOT NULL,
    component_scores JSONB NOT NULL,
    market_data JSONB NOT NULL,
    created_at TIMESTAMP DEFAULT NOW(),
    INDEX idx_dm_crypto_asymmetry_symbol (symbol),
    INDEX idx_dm_crypto_asymmetry_created (created_at)
);

-- Performance tracking
CREATE TABLE dm_performance (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    decision_id UUID REFERENCES dm_decisions(id),
    outcome_id UUID,
    pnl FLOAT8,
    execution_quality FLOAT8,
    risk_realized FLOAT8,
    performance_score FLOAT8,
    created_at TIMESTAMP DEFAULT NOW(),
    INDEX idx_dm_performance_decision (decision_id),
    INDEX idx_dm_performance_outcome (outcome_id)
);
```

## Configuration

### Decision Maker Configuration
```yaml
decision_maker:
  risk_management:
    max_position_size: 0.05  # 5% max position
    max_portfolio_risk: 0.20  # 20% max portfolio risk
    correlation_threshold: 0.7  # Max correlation between positions
  
  crypto_asymmetry:
    enabled: true
    asymmetry_threshold: 0.5
    budget_scaling_factor: 1.5
    safety_brakes:
      kelly_fraction_cap: 0.25
      concentration_limit: 0.10
      drawdown_aware_ratchet: true
  
  curators:
    risk:
      weight: 0.3
      veto_threshold: 0.8
    allocation:
      weight: 0.2
      veto_threshold: 0.7
    timing:
      weight: 0.2
      veto_threshold: 0.6
    cost:
      weight: 0.15
      veto_threshold: 0.5
    compliance:
      weight: 0.15
      veto_threshold: 0.9
  
  learning:
    learning_rate: 0.01
    adaptation_threshold: 0.1
    performance_window: 50
    recent_window: 10
```

## Success Metrics

### Phase 1 Success Criteria
- [ ] Decision Maker core class implemented
- [ ] Curator system working
- [ ] Context engine functional
- [ ] Basic decision process working

### Phase 2 Success Criteria
- [ ] Risk assessment engine complete
- [ ] Budget allocation working
- [ ] Portfolio state management functional
- [ ] Decision quality metrics >80%

### Phase 3 Success Criteria
- [ ] Crypto asymmetry module working
- [ ] Asymmetry detectors functional
- [ ] Budget scaling working
- [ ] Crypto-specific optimizations active

### Phase 4 Success Criteria
- [ ] Self-learning system working
- [ ] Performance adaptation active
- [ ] Decision quality improving over time
- [ ] System stability >99.9%

---

*This build plan provides the complete foundation for implementing the Decision Maker module with detailed risk management, crypto asymmetry detection, and self-learning capabilities.*
